{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hubuum documentation","text":""},{"location":"#license","title":"License","text":"<p>Hubuum is licensed under the Creative Commons Legal Code, CC0 1.0 Universal.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Django</li> <li>Django REST Framework</li> <li>mkdocs</li> <li>mkdocs-material</li> <li>django-rest-knox</li> </ul>"},{"location":"about/","title":"About","text":"<p>Hubuum is a non-opinionated content management database. Through the use of extensions, it can be used to store data from nearly any source, while providing a unified API to access all the data.</p>"},{"location":"about/#features","title":"Features","text":"<ul> <li>A REST API to access your resources</li> <li>Fine-grained group-based permissions</li> <li>User-defined classes and fields, optionally defined through JSON Schemas</li> </ul>"},{"location":"about/#maintainers","title":"Maintainers","text":"<ul> <li>Terje Kvernes</li> </ul>"},{"location":"api/","title":"The hubuum API","text":""},{"location":"api/#creating-classes","title":"Creating classes","text":"<p>Classes are created via the API. The API endpoint is <code>/api/v1/dynamic/</code>. Creating a class is done by sending a POST request to the endpoint with a JSON body containing the class definition. The class definition is a JSON object with the following keys:</p> <ul> <li><code>name</code> (required): The name of the class. This must be unique.</li> <li><code>schema</code> (optional): A JSON schema that the objects of this class must adhere to. If this is not provided, the objects of this class will be free-form.</li> <li><code>validate_schema</code> (optional): A boolean value that determines whether the schema is enforced or not. If this is not provided, the schema will not be enforced.</li> <li><code>namespace</code> (required): The namespace that this class belongs to. This must be a valid namespace ID.</li> </ul> <p>For more information about namespaces, permissions.</p> <pre><code>```python\n# For a free-form class:\nclient.post(\n    \"/api/v1/dynamic/\",\n    {\n        \"name\": \"Host\",\n        \"namespace\": 1,\n    },\n)\n# For a class with a schema:\nvalid_schema = {\n\"$id\": \"https://example.com/person.schema.json\",\n\"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n\"title\": \"Person\",\n\"type\": \"object\",\n\"additionalProperties\": False,\n\"properties\": {\n    \"age\": {\n        \"description\": \"Age in years which must be equal to or greater than zero.\",\n        \"type\": \"integer\",\n        \"minimum\": 0,\n        \"maximum\": 150,\n    },\n}\nclient.post(\n    \"/api/v1/dynamic/\",\n    {\n        \"name\": \"Person\",\n        \"namespace\": 1,\n        \"schema\": valid_schema,\n        \"validate_schema\": True,\n    },\n)\n```\n</code></pre>"},{"location":"api/#creating-objects","title":"Creating objects","text":"<p>Objects are created via the API. The API endpoint is <code>/api/v1/dynamic/&lt;class_name&gt;/</code>. Creating an object is done by sending a POST request to the endpoint with a JSON body containing the object definition. The object definition is a JSON object with the following keys:</p> <ul> <li><code>name</code> (required): The name of the object. This must be unique within the class.</li> <li><code>json_data</code> (required): A JSON object that is the object data. This must adhere to the schema of the class, if one is defined.</li> <li><code>namespace</code> (required): The namespace that this object belongs to. This must be a valid namespace ID.</li> </ul> <p>Note that this implies that classes can belong to different namespaces than the objects they contain. This is intentional, and allows for a more flexible data model. Within a class, objects can again belong to different namespaces. This ensures that an organization may share a class, but not the objects within it, or vice versa.</p> <pre><code>```python\nclient.post(\n    \"/api/v1/dynamic/Person/\",\n    {\n        \"name\": \"John Doe\",\n        \"json_data\": {\n            \"age\": 42,\n        },\n        \"namespace\": 1,\n    },\n)\n```\n</code></pre>"},{"location":"api/#working-with-individual-classes-or-objects","title":"Working with individual classes or objects","text":"<p>As per standard REST practice, individual classes or objects can be accessed via their unique name. The API endpoints are <code>/api/v1/dynamic/&lt;class_name&gt;</code> and <code>/api/v1/dynamic/&lt;class_name&gt;/&lt;object_name&gt;/</code> for objects. These endpoints all support the default REST methods: GET, PUT, PATCH, and DELETE.</p>"},{"location":"api/#filtering","title":"Filtering","text":"<p>Querying using the API is done via standard HTTP GET requests using django-filter. The API supports filtering, ordering, and pagination. The API also supports querying JSON fields of the models directly (see below).</p> <p>Note</p> <p>Filtering on a field that does not exist, or using an unsupported lookup key for an existing, field will return <code>400 Bad Request</code>, with some information about the fields or lookups that failed.</p>"},{"location":"api/#operators","title":"Operators","text":""},{"location":"api/#text-or-character-fields","title":"Text or character fields","text":"<p>For text or character fields, the following operators are supported:</p> <ul> <li><code>exact</code> (default)</li> <li><code>startswith</code> (case-sensitive, string start with)</li> <li><code>endswith</code> (case-sensitive, string end with)</li> <li><code>contains</code> (case-sensitive, string contains)</li> <li><code>regex</code> (case-sensitive, regular expression)</li> </ul> <p>These may also be prefixed with <code>i</code> to make them case-insensitive, eg. <code>icontains</code>.</p>"},{"location":"api/#examples-for-text-or-character-fields","title":"Examples for text or character fields","text":"<pre><code>```bash\n# These two are identical:\n/iam/users/?name=johndoe\n/iam/users/?name__exact=johndoe\n\n# Find all users with a username that ends with \"doe\"\n/iam/users/?name__endswith=doe\n/iam/users/?name__regex=doe$\n\n# Find all users that start with \"john\"\n/iam/users/?name__startswith=john\n/iam/users/?name__regex=^john\n\n# Find all users that start with \"j\", contains \"do\", and ends with \"e\"\n/iam/users/?name__regex=^j.*do.*e$\n\n# Find all Persons with a name that contains \"doe\"\n/api/v1/dynamic/Persons/?json_data_lookup__name__icontains=doe\n```\n</code></pre>"},{"location":"api/#numeric-fields","title":"Numeric fields","text":"<p>For numeric fields, the following operators are supported:</p> <ul> <li><code>exact</code> (default)</li> <li><code>gt</code> (greater than)</li> <li><code>gte</code> (greater than or equal to)</li> <li><code>lt</code> (less than)</li> <li><code>lte</code> (less than or equal to)</li> <li><code>range</code> (between)</li> </ul>"},{"location":"api/#examples-for-numeric-fields","title":"Examples for numeric fields","text":"<pre><code>```bash\n# These two are identical:\n/iam/users/?id=1\n/iam/users/?id__exact=1\n\n# Find all users with an ID over 5 but under 9, these three are identical\n/iam/users/?id__gt=5&amp;id__lt=9\n/iam/users/?id__gte=6&amp;id__lte=8\n/iam/users/?id__range=6,8\n```\n</code></pre>"},{"location":"api/#date-fields","title":"Date fields","text":"<p>For date fields, the following operators are supported:</p> <ul> <li><code>exact</code> (default)</li> <li><code>day</code> (day of the month)</li> <li><code>week</code> (week of the year)</li> <li><code>month</code> (month of the year)</li> <li><code>year</code> (year)</li> <li><code>quarter</code> (quarter of the year)</li> <li><code>week_day</code> (day of the week)</li> <li><code>iso_week_day</code> (day of the week, ISO 8601)</li> <li><code>iso_year</code> (week of the year, ISO 8601)</li> </ul>"},{"location":"api/#json-fields-object-data","title":"JSON fields, object data","text":"<p>The API supports querying JSON fields of the models directly. This is done by querying the field name suffixed by <code>__lookup</code>. For example, to query the <code>json_data</code> field of an object, you would use <code>json_data_lookup</code> as the lookup key.</p> <p>When querying into the json field, use <code>__</code> to separate the keys. Some mapping examples:</p> <pre><code>```python\n1. json_data['foo']==value\n# /?json_data_lookup__foo=value\n2. json_data['foo']['bar']==value\n# /?json_data_lookup__foo__bar=value\n3. if 'value'.lower() in json_data['foo']['bar'].lower()\n# /?json_data_lookup__foo__bar__icontains=value\n```\n</code></pre> <p>Warning</p> <p>You always want to use case-insensitive operators for JSON fields. Otherwise, you will get unexpected (ie, no) results.</p>"},{"location":"authentication/","title":"Authentication","text":"<p>Hubuum uses Django REST Framework for its API. In typical REST fashion, the authentication endpoint for username and password returns a token, which is then used for the rest of the API. The endpoint is <code>/api/auth/login</code> and one can code such as this to log in:_</p> <pre><code>```python\nbasic_auth = b64encode(f\"{username}:{password}\".encode(\"utf-8\")).decode(\"ascii\")\nclient = APIClient()\nclient.credentials(HTTP_AUTHORIZATION=auth)\nclient.post(\"/api/auth/login/\")\n```\n</code></pre> <p>In return, on a successful login, one will get a JSON blob akin to this. Note that the token in the example is truncated for brevity. By default the token is 64 characters long, and has an expiry of 10 hours. Every login from a user will generate a new token, and every generated token is valid until it expires.</p> <pre><code>```json\n{\n    \"expiry\": \"2023-11-23T09:33:53.990672Z\",\n    \"token\":\"b61...77f\" \n}\n```\n</code></pre> <p>Using the token is done as follows:</p> <pre><code>```python\nclient = APIClient()\nclient.credentials(HTTP_AUTHORIZATION=f\"Token {token}\")\n```\n</code></pre>"},{"location":"authentication/#deleting-a-single-token","title":"Deleting a single token","text":"<p>Any token can be deleted by calling the <code>/api/auth/logout</code> endpoint. This will invalidate the token in question.</p>"},{"location":"authentication/#purging-all-tokens-for-a-user","title":"Purging all tokens for a user","text":"<p>If you need to purge all tokens for a user, you can do so by calling the <code>/api/auth/logoutall</code> endpoint. This will invalidate all tokens for the user owning the token in question.</p>"},{"location":"code-style/","title":"Code Style","text":""},{"location":"code-style/#general","title":"General","text":"<ul> <li>ruff is used to sort imports, general formatting, and linting. It is also enforced by the CI.</li> <li>coverage is used to check code coverage. Anything below 100% is considered a failure.</li> </ul> <p>Ruff is used to replace pylint, flake8, isort, and black. It is configured via the <code>pyproject.toml</code> file.</p>"},{"location":"code-style/#checking-code-style","title":"Checking Code Style","text":"<ul> <li><code>tox -e lint</code> will run the current linting tools on the codebase. This is a validate-only run, and will not make any changes to the codebase. This is also run by the CI, and must pass for a pull request to be merged.</li> </ul>"},{"location":"code-style/#fixing-code-style","title":"Fixing Code Style","text":"<ul> <li><code>tox -e lint-fix</code> will allow ruff to fix any issues it can automatically. This will make (cosmetic) changes to the codebase.</li> </ul>"},{"location":"code-style/#checking-code-coverage","title":"Checking Code Coverage","text":"<ul> <li><code>tox -e coverage</code> will run coverage on the codebase. Afterwards, <code>coverage report -m</code> can be used to see the coverage report.</li> </ul>"},{"location":"code-style/#working-in-visual-studio-code","title":"Working in Visual Studio Code","text":"<p>Using ruff only for both formatting and listing works well well with VSCode's Ruff extension. Suggested configuration:</p> <pre><code>    \"[python]\": {\n\"editor.defaultFormatter\": \"charliermarsh.ruff\"\n},\n\"editor.codeActionsOnSave\": {\n\"source.organizeImports\": \"explicit\",\n\"source.fixAll\": \"explicit\",\n\"source.fixAll.ruff\": \"explicit\"\n},\n</code></pre>"},{"location":"code-style/#external-resources","title":"External resources","text":"<p>Coveralls and Codiga are used to check code coverage and code quality respectively for pull requests. Both have to pass without errors (ie, no decrease in coverage or code quality) for a pull request to be merged. The following links can be used to view the current status of the project:</p> <ul> <li>Coveralls.io</li> <li>Codiga.io</li> </ul>"},{"location":"configuration/","title":"Hubuum Django App Environment Variables","text":"<p>This document provides an overview of the environment variables that can be set to influence the behavior of the Hubuum Django app.</p> <p>Note</p> <p>Hubuum validates all environment variables prefixed with HUBUUM_. Any unexpected environment variables under that prefix will be reported and the application will exit.</p>"},{"location":"configuration/#core-options","title":"Core options","text":"<ul> <li><code>HUBUUM_SECRET_KEY</code>: Setting this sets the secret key for the Django framework. If you do not set this yourself, a random key will be generated on startup. Setting this environment variable will put the application into production mode.</li> </ul>"},{"location":"configuration/#database-access","title":"Database Access","text":"<p>Currently supported engines are \"django.db.backends.postgresql\" and \"django.db.backends.sqlite3\". If \"django.db.backends.sqlite3\" is chosen, the only other option used is <code>HUBUUM_DATABASE_NAME</code>.</p> <ul> <li><code>HUBUUM_DATABASE_ENGINE</code>: Sets the database engine. Defaults to \"django.db.backends.postgresql\".</li> <li><code>HUBUUM_DATABASE_NAME</code>: Sets the name of the database. Defaults to \"hubuum\".</li> <li><code>HUBUUM_DATABASE_USER</code>: Sets the database user. Defaults to \"hubuum\".</li> <li><code>HUBUUM_DATABASE_PASSWORD</code>: Sets the password for the database user. Defaults to <code>None</code>. Must be set if <code>HUBUUM_DATABASE_ENGINE</code> is \"django.db.backends.postgresql\".</li> <li><code>HUBUUM_DATABASE_HOST</code>: Sets the database host. Defaults to \"localhost\".</li> <li><code>HUBUUM_DATABASE_PORT</code>: Sets the port for the database. Defaults to 5432.</li> </ul>"},{"location":"configuration/#logging","title":"Logging","text":"<p>For detailed information on logging, see the logging documentation. Loggers that take log values as input accept the following values: DEBUG, INFO, WARNING, ERROR, CRITICAL.</p>"},{"location":"configuration/#core-logging-options","title":"Core logging options","text":"<ul> <li><code>HUBUUM_LOGGING_LEVEL</code>: Sets the default logging level for all sources. Defaults to \"CRITICAL\".</li> <li><code>HUBUUM_LOGGING_PRODUCTION</code>: Determines if logging is in production mode or not. In production we get no colored output and the JSON layout is compact. Defaults to <code>False</code>. Note that if <code>HUBUUM_SECRET_KEY</code> was set above, this defaults to <code>True</code>, but may be overridden explicitly.</li> <li><code>HUBUUM_LOGGING_MAX_BODY_SIZE</code>: Sets the maximum size for the logging of the request.body. Defaults to 3k.</li> <li><code>HUBUUM_LOGGING_COLLAPSE_REQUEST_ID</code>: Only applies to rich console output, never applies for production logging. If set to True, collapse request_ids to <code>xxx...xxx</code> to save some screen real estate. Defaults to True.</li> </ul>"},{"location":"configuration/#individual-loggers","title":"Individual loggers","text":"<p>These are all the loggers for Hubuum. Their logging levels can be individually set using their logger name prefixed with <code>HUBUUM_LOGGING_LEVEL_</code>. All sources, except for <code>DJANGO</code>, default to the level of <code>HUBUUM_LOGGING_LEVEL</code>, so if one wants to see <code>AUTH</code> messages on the debug level, one can set <code>HUBUUM_LOGGING_LEVEL_AUTH=DEBUG</code> in the environment.</p> <p>Note</p> <p><code>HUBUUM_LOGGING_LEVEL_DJANGO</code> is the default structlog Django logger but provides very little functionality for Hubuum. Due to this, this logger requires explicit logging levels to be set. Setting <code>HUBUUM_LOGGING_LEVEL</code> will NOT transfer this logging level to this logger. In the future, this logger may be disabled completely.</p> Source Description Events Fields <code>AUTH</code> Authentication events login, logout, failure id, request_id <code>API</code> API actions, including direct object manipulation created, deleted, updated id, model, user, request_id <code>DJANGO</code> Structlog default Django request loggers request_started, request_finished request, user_agent / request, code <code>INTERNAL</code> Internal events in Hubuum Undefined Any <code>MANUAL</code> Manual log events manual Any <code>MIGRATION</code> On startup database migrations, logged at the <code>DEBUG</code> level created id, model, request_id <code>HTTP</code> HTTP requests and responses request, response content, method, proxy_ip, remote_ip, request_id, request_size, run_time_ms, status_code, status_label, request_id <code>OBJECT</code> Object manipulation created, updated, deleted request_id, user, model ++ <code>SIGNAL</code> Signals undefined Any <p>To get a quick overview of the logging output, one can run a test with logging set to debug:</p> <pre><code>HUBUUM_LOGGING_LEVEL=DEBUG pytest hubuum/api/v1/tests/test_20_hosts.py -vv -s\n</code></pre>"},{"location":"configuration/#sentry-support","title":"Sentry support","text":"<p>Hubuum supports Sentry for log tracking. See their guide for python for details. The following environment variables can be used to configure Sentry:</p> <ul> <li><code>HUBUUM_SENTRY_DSN</code>: Sets the Sentry DSN for log tracking. Defaults to an empty string. If this is set, Sentry will be enabled.</li> <li><code>HUBUUM_SENTRY_LEVEL</code>: Sets the Sentry logging level. Defaults to <code>ERROR</code>.</li> <li><code>HUBUUM_SENTRY_TRACES_SAMPLE_RATE</code>: Set the sample rate used. This number from 0 (0%) and 1 (100%) of the events passed to sentry. Defaults to <code>1.0</code> (100%).</li> <li><code>HUBUUM_SENTRY_PII</code>: Send personal identifiable information (PII). Default is <code>False</code>.</li> <li><code>HUBUUM_SENTRY_ENVIRONMENT</code>: Set the environment label used, defaults to <code>production</code>.</li> </ul>"},{"location":"configuration/#request-handling","title":"Request handling","text":"<p>Hubuum supports logging slow and very slow requests. This manipulates the events logged by the <code>REQUEST</code> logger.</p> <ul> <li><code>HUBUUM_REQUEST_THRESHOLD_SLOW</code>: The amount of time, in milliseconds, a request can take before it is considered slow. Defaults to <code>1000</code> (1s).</li> <li><code>HUBUUM_REQUEST_THRESHOLD_VERY_SLOW</code>: The amount of time, in milliseconds, a request can take before it is considered very slow. Defaults to <code>5000</code> (5s).</li> <li><code>HUBUUM_REQUEST_LOG_LEVEL_SLOW</code>: The log level a slow request gets escalated to, defaults to <code>WARNING</code>.</li> <li><code>HUBUUM_REQUEST_LOG_LEVEL_VERY_SLOW</code>: The log level a very slow request gets escalated to, defaults to <code>ERROR</code>.</li> </ul> <p>In addition to escalating the <code>log_level</code>, the following fields are added to the event:</p> <ul> <li><code>original_log_level</code>: This is the original log level of the event.</li> <li>One of <code>slow_response</code> or <code>very_slow_response</code> is set to <code>True</code>.</li> </ul> <p>With the default setup, this can look something like this:</p> <pre><code>2023-05-23T11:38:27.353445Z [warning ] response [hubuum.request] content=... method=GET original_log_level=10 path=/api/v1/resources/hosts/ run_time_ms=1438.51 slow_response=True status_code=200 status_label=OK\n2023-05-23T11:38:33.020905Z [error   ] response [hubuum.request] content=... method=GET original_log_level=10 path=/api/v1/resources/hosts/ run_time_ms=5664.79 status_code=200 status_label=OK very_slow_response=True\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":""},{"location":"contributing/#reporting-bugs","title":"Reporting bugs","text":"<p>If you find a bug in, or have a suggestion for Hubuum, please create an issue on GitHub. Generally speaking it is suggested to create an issue before creating a pull request.</p> <p>Pull Requests are very welcome. For faster turnaround, please see the Pull Request Guidelines below.</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, please make sure the following is done:</p> <ol> <li>Fork the repository and create your branch from <code>main</code>.</li> <li>Check that the tests pass and code style is valid by running <code>tox -e format</code> and <code>tox -e flake8</code>.</li> <li>Check that coverage is 100% by running <code>tox -e coverage</code> and then <code>coverage report -m</code>.</li> </ol>"},{"location":"contributing/#local-testing","title":"Local testing","text":"<p>If you have both postgresql and sqlite available locally, you can run the complete test suite by issuing <code>tox</code>. The default environment list is rather large (see <code>tox -l</code>). You can also test against only one of them. Ideally you want to set your \"default\" engine setup by using the same enviroment variables as one uses under production:</p> <ul> <li><code>HUBUUM_DATABASE_ENGINE</code>: Sets the database engine. Defaults to \"django.db.backends.postgresql\".</li> <li><code>HUBUUM_DATABASE_NAME</code>: Sets the name of the database. Defaults to \"hubuum\".</li> <li><code>HUBUUM_DATABASE_USER</code>: Sets the database user. Defaults to \"hubuum\".</li> <li><code>HUBUUM_DATABASE_PASSWORD</code>: Sets the password for the database user. Defaults to <code>None</code>.</li> <li><code>HUBUUM_DATABASE_HOST</code>: Sets the database host. Defaults to \"localhost\".</li> <li><code>HUBUUM_DATABASE_PORT</code>: Sets the port for the database. Defaults to 5432.</li> </ul>"},{"location":"contributing/#postgresql","title":"Postgresql","text":"<p>You MUST specify the following variables for postgresql, even when using tox to ask for a postgresql enviroment (ie, <code>python310-django41-postgres</code>). The database name and engine will however be automatically set.</p> <ul> <li><code>HUBUUM_DATABASE_USER</code></li> <li><code>HUBUUM_DATABASE_PASSWORD</code></li> <li><code>HUBUUM_DATABASE_HOST</code></li> <li><code>HUBUUM_DATABASE_PORT</code></li> </ul> <p>You can see the available sqlite environments by doing <code>tox -l | grep postgres</code>.</p> <p>You can run the postgresql suite by itself by doing <code>tox -e $( tox -l | grep postgres | tr '\\n' ',' )</code>.</p>"},{"location":"contributing/#sqlite","title":"SQLite","text":"<p>No configuration is required when using Tox and asking for an sqlite environment. The database will be created in <code>{envtmpdir}/hubuum.db</code>, typically something like <code>.tox/python310-django41-sqlite/tmp</code>, and it will be deleted after use. The engine will be automaticall set.</p> <p>You can see the available sqlite environments by doing <code>tox -l | grep sqlite</code>.</p> <p>You can run the SQLite suite by itself by doing <code>tox -e $( tox -l | grep sqlite | tr '\\n' ',' )</code>.</p>"},{"location":"contributing/#coverage","title":"Coverage","text":"<p>Coverage (<code>tox -e coverage &amp;&amp; tox -e report</code>) assumes that the local environment variables are set up to allow for testing. See the sections for postgresql and SQLite above.</p>"},{"location":"examples/","title":"Examples of using the hubuum API","text":"<pre><code>```bash\n# Get the user with the username \"admin\" (it is unique)\nGET /api/v1/users/?username=admin\n\n# Assume there is only one user with the username \"admin\"\nGET /api/v1/users/admin\n\n# Change the email address of the user with the username \"admin\"\nPUT /api/v1/users/admin {\"email\": \"admin@localhost\"}\n\n# Get hosts that end with \"example.tld\" in their name\nGET /api/v1/dynamic/Host/?name__endswith=example.tld\n```\n</code></pre> <p>Note</p> <p>Note the value of the search field (ie, <code>example.tid</code> for <code>name__endswith=example.tld</code>) is typed for lookup operations. If this value is deemed numeric, allowed lookups become exact, gt, gte, lt, lte, and range. This again means that <code>name__endswith=9</code> will give a 400 error for an invalid combination of lookup type (endswith, texual) and value (9, numeric).</p> <p>Warning</p> <p>You always want to use case-insensitive operators for JSON fields. Otherwise, you will get unexpected (ie, no) results.</p>"},{"location":"installation/","title":"Installation","text":"<p>Note</p> <p>Hubuum is a work in progress and is not ready for production use.</p> <p>Currently there are no releases, so...</p> <pre><code>```bash\ngit clone git@github.com:terjekv/hubuum.git\ncd hubuum\npython -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\npython manage.py runserver\n```\n</code></pre> <p>If you want to work on development for Hubuum, you can install the additional development requirements:</p> <pre><code>```bash\npip install -r requirements-dev.txt\n```\n</code></pre>"},{"location":"logging/","title":"Logging","text":""},{"location":"logging/#core-logging-options","title":"Core logging options","text":"<ul> <li><code>HUBUUM_LOGGING_LEVEL</code>: Sets the default logging level for all sources. Defaults to \"CRITICAL\".</li> <li><code>HUBUUM_LOGGING_PRODUCTION</code>: Determines if logging is in production mode or not. In production we get no colored output and the JSON layout is compact. Defaults to <code>False</code>. Note that if <code>HUBUUM_SECRET_KEY</code> is set above, this defaults to <code>True</code>, but may be overridden explicitly.</li> <li><code>HUBUUM_LOGGING_MAX_BODY_SIZE</code>: Sets the maximum size for the logging of the request.body. Defaults to 3k.</li> <li><code>HUBUUM_LOGGING_COLLAPSE_REQUEST_ID</code>: Only applies to rich console output, never applies for production logging. If set to True, collapse request_ids to <code>xxx...xxx</code> to save some screen real estate. Defaults to True.</li> </ul>"},{"location":"logging/#standard-logging","title":"Standard Logging","text":"<p>Hubuum logs to the console as per the 12-factor app methodology.</p> <p>To control the logging level, set the <code>HUBUUM_LOGGING_LEVEL</code> environment variable to one of the following values:</p> <ul> <li><code>critical</code></li> <li><code>error</code></li> <li><code>warning</code></li> <li><code>info</code></li> <li><code>debug</code></li> </ul> <p>One may also set the logging level for specific sources. The following environment variables are available:</p> <ul> <li><code>HUBUUM_LOGGING_LEVEL_API</code>: Sets the logging level for the API. Defaults to the value of <code>HUBUUM_LOGGING_LEVEL</code>.</li> <li><code>HUBUUM_LOGGING_LEVEL_AUTH</code>: Sets the logging level for authentication. Defaults to the value of <code>HUBUUM_LOGGING_LEVEL</code>.</li> <li><code>HUBUUM_LOGGING_LEVEL_HTTP</code>: Sets the logging level for HTTP traffic, typically requests and responses. Defaults to the value of <code>HUBUUM_LOGGING_LEVEL</code>.</li> <li><code>HUBUUM_LOGGING_LEVEL_OBJECT</code>: Sets the logging level for object manipulation. Defaults to the value of <code>HUBUUM_LOGGING_LEVEL</code>.</li> <li><code>HUBUUM_LOGGING_LEVEL_SIGNAL</code>: Sets the logging level for signals, typically used for object manipulation. Defaults to the value of <code>HUBUUM_LOGGING_LEVEL</code>.</li> <li><code>HUBUUM_LOGGING_LEVEL_INTERNAL</code>: Sets the logging level for internal logging, typically used for introspection. Defaults to the value of <code>HUBUUM_LOGGING_LEVEL</code>.</li> <li><code>HUBUUM_LOGGING_LEVEL_MANUAL</code>: Sets the logging level for manual logs. Defaults to the value of <code>HUBUUM_LOGGING_LEVEL</code>.</li> <li><code>HUBUUM_LOGGING_LEVEL_MIGRATION</code>: Sets the logging level for migration logs. Defaults to the value of <code>HUBUUM_LOGGING_LEVEL</code>.</li> <li><code>HUBUUM_LOGGING_LEVEL_DJANGO</code>: Sets the logging level for Django. Defaults to <code>ERROR</code>. This logger is not recommended for use.</li> </ul>"},{"location":"logging/#request-identifiers","title":"Request identifiers","text":"<p>Hubuum applies a request_id to contextually related log entries. This request_id follows events from a request to a response, leading to logs such as these:</p> <pre><code>```\n2023-07-23T21:16:30.863144Z [info     ]  \u2022 request          [hubuum.http] request_id=a07...2f4 method=PATCH remote_ip=127.0.0.1 proxy_ip= user_agent= path=/api/v1/resources/hosts/yes request_size=12 body={\"serial\":1}\n2023-07-23T21:16:30.896036Z [info     ]  \u2022 updated          [hubuum.object] request_id=a07...2f4 model=Host id=1\n2023-07-23T21:16:30.896433Z [debug    ]  \u2022 updated          [hubuum.api] request_id=a07...2f4 model=Host user=tmp instance=1\n2023-07-23T21:16:30.896900Z [info     ]  \u2022 response         [hubuum.http] request_id=a07...2f4 user=tmp method=PATCH status_code=200 status_label=OK path=/api/v1/resources/hosts/yes content={\"id\":1,\"created_at\":\"2023-07-23T21:16:30.725568Z\",\"updated_at\":\"2023-07-23T21:16:30.892566Z\",\"name\":\"yes\",\"fqdn\":\"\",\"serial\":\"1\",\"registration_date\":\"2023-07-23T21:16:30.725586Z\",\"namespace\":1,\"type\":null,\"room\":null,\"jack\":null,\"purchase_order\":null,\"person\":null} run_time_ms=33.75\n2023-07-23T21:16:30.908318Z [info     ]  \u2022 updated          [hubuum.object] request_id=98f...8d2 model=User id=1\n2023-07-23T21:16:30.912440Z [info     ]  \u2022 created          [hubuum.object] request_id=98f...8d2 model=AuthToken id=2ec...aa0 : superuser\n2023-07-23T21:16:30.913254Z [info     ]  \u2022 request          [hubuum.http] request_id=98f...8d2 method=DELETE remote_ip=127.0.0.1 proxy_ip= user_agent= path=/api/v1/iam/namespaces/namespace1 request_size=0 body=\n2023-07-23T21:16:30.928717Z [debug    ]  \u2022 deleted          [hubuum.api] request_id=98f...8d2 model=Namespace user=superuser instance=1\n2023-07-23T21:16:30.980427Z [info     ]  \u2022 deleted          [hubuum.object] request_id=98f...8d2 model=Permission id=1\n2023-07-23T21:16:30.984305Z [info     ]  \u2022 deleted          [hubuum.object] request_id=98f...8d2 model=Host id=1\n2023-07-23T21:16:30.987523Z [info     ]  \u2022 deleted          [hubuum.object] request_id=98f...8d2 model=Namespace id=1\n2023-07-23T21:16:30.987982Z [info     ]  \u2022 response         [hubuum.http] request_id=98f...8d2 user=superuser method=DELETE status_code=204 status_label=No Content path=/api/v1/iam/namespaces/namespace1 content= run_time_ms=74.71\n```\n</code></pre> <p>Notice how the request_id also applies to the cascading events caused by the deletion of the namespace \"namespace1\". Also note that the dots would be colored according to the request_id for the entry.</p>"},{"location":"logging/#corrolation-ids","title":"Corrolation IDs","text":"<p>Hubuum supports the use of corrolation IDs. These are IDs that are passed in via the <code>X-Corrolation-ID</code> header. If this header is present, Hubuum will log it in addition to the request_id for the request. This allows for the correlation of logs across multiple services and / or requests.</p>"},{"location":"logging/#sentry","title":"Sentry","text":"<p>Hubuum can be configured to send logs to Sentry. To do this, set the <code>SENTRY_DSN</code> environment variable to the DSN for your Sentry project.</p>"},{"location":"logging/#development","title":"Development","text":"<p>During development, hubuum produces colored output. To disable this, set the <code>HUBUUM_LOGGING_PRODUCTION</code> environment variable to <code>True</code>.</p>"},{"location":"model/","title":"References","text":""},{"location":"model/#core-models","title":"Core models","text":"<p>Core models for hubuum. These are the foundation that permissions and resources are built on.</p> <p>Core models for hubuum.</p>"},{"location":"model/#hubuum.models.core.Attachment","title":"<code>Attachment</code>","text":"<p>         Bases: <code>NamespacedHubuumModel</code></p> <p>A model for the attachments data for objects.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Attachment(NamespacedHubuumModel):\n\"\"\"A model for the attachments data for objects.\"\"\"\n\n    attachment = models.FileField(unique=True)\n    hubuum_class = models.ForeignKey(\"HubuumClass\", on_delete=models.CASCADE)\n    hubuum_object = models.ForeignKey(\"HubuumObject\", on_delete=models.CASCADE)\n    sha256 = models.CharField(max_length=64, unique=True, editable=False)\n    size = models.PositiveIntegerField(editable=False)\n    original_filename = models.CharField(max_length=255, editable=False)\n\n    class Meta:\n\"\"\"Meta for the model.\"\"\"\n\n        ordering = [\"id\"]\n\n    def __str__(self) -&gt; str:\n\"\"\"Stringify the object, used to represent the object towards users.\"\"\"\n        return str(self.get_auto_id())\n\n    def save(self, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Override the save method to compute the sha256 hash and size of the uploaded file.\"\"\"\n        file_contents = self.attachment.read()\n        self.sha256 = hashlib.sha256(file_contents).hexdigest()\n        self.size = self.attachment.size\n        self.original_filename = self.attachment.name\n        self.attachment.name = self.generate_sha256_filename(self.sha256)\n        super().save(*args, **kwargs)\n\n    def generate_sha256_filename(self, sha256_hash: str):\n\"\"\"Generate a custom filename for the uploaded file using its sha256 hash.\"\"\"\n        return f\"attachments/file/{sha256_hash}\"\n</code></pre>"},{"location":"model/#hubuum.models.core.Attachment.Meta","title":"<code>Meta</code>","text":"<p>Meta for the model.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Meta:\n\"\"\"Meta for the model.\"\"\"\n\n    ordering = [\"id\"]\n</code></pre>"},{"location":"model/#hubuum.models.core.Attachment.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the object, used to represent the object towards users.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Stringify the object, used to represent the object towards users.\"\"\"\n    return str(self.get_auto_id())\n</code></pre>"},{"location":"model/#hubuum.models.core.Attachment.generate_sha256_filename","title":"<code>generate_sha256_filename(sha256_hash)</code>","text":"<p>Generate a custom filename for the uploaded file using its sha256 hash.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def generate_sha256_filename(self, sha256_hash: str):\n\"\"\"Generate a custom filename for the uploaded file using its sha256 hash.\"\"\"\n    return f\"attachments/file/{sha256_hash}\"\n</code></pre>"},{"location":"model/#hubuum.models.core.Attachment.save","title":"<code>save(*args, **kwargs)</code>","text":"<p>Override the save method to compute the sha256 hash and size of the uploaded file.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def save(self, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Override the save method to compute the sha256 hash and size of the uploaded file.\"\"\"\n    file_contents = self.attachment.read()\n    self.sha256 = hashlib.sha256(file_contents).hexdigest()\n    self.size = self.attachment.size\n    self.original_filename = self.attachment.name\n    self.attachment.name = self.generate_sha256_filename(self.sha256)\n    super().save(*args, **kwargs)\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentManager","title":"<code>AttachmentManager</code>","text":"<p>         Bases: <code>HubuumModel</code></p> <p>Managing what models may have attachments and what constraints are imposed.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class AttachmentManager(HubuumModel):\n\"\"\"Managing what models may have attachments and what constraints are imposed.\"\"\"\n\n    hubuum_class = models.ForeignKey(\"HubuumClass\", on_delete=models.CASCADE)\n    enabled = models.BooleanField(default=False, null=False)\n    per_object_count_limit = models.PositiveIntegerField(default=0, null=False)\n    per_object_individual_size_limit = models.PositiveIntegerField(default=0, null=False)\n    per_object_total_size_limit = models.PositiveIntegerField(default=0, null=False)\n\n    class Meta:\n\"\"\"Meta for the model.\"\"\"\n\n        ordering = [\"id\"]\n\n    def __str__(self) -&gt; str:\n\"\"\"Stringify the object, used to represent the object towards users.\"\"\"\n        return str(self.get_auto_id())\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentManager.Meta","title":"<code>Meta</code>","text":"<p>Meta for the model.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Meta:\n\"\"\"Meta for the model.\"\"\"\n\n    ordering = [\"id\"]\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentManager.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the object, used to represent the object towards users.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Stringify the object, used to represent the object towards users.\"\"\"\n    return str(self.get_auto_id())\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel","title":"<code>AttachmentModel</code>","text":"<p>         Bases: <code>models.Model</code></p> <p>A model that supports attachments.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class AttachmentModel(models.Model):\n\"\"\"A model that supports attachments.\"\"\"\n\n    class Meta:\n\"\"\"Meta for the model.\"\"\"\n\n        abstract = True\n\n    def attachments_are_enabled(self) -&gt; bool:\n\"\"\"Check if the model is ready to receive attachments.\"\"\"\n        return AttachmentManager.objects.filter(\n            hubuum_class=self.hubuum_class, enabled=True\n        ).exists()\n\n    def attachments(self) -&gt; List[Attachment]:\n\"\"\"List all attachments registered to the object.\"\"\"\n        if not self.attachments_are_enabled():\n            raise UnsupportedAttachmentModelError(\n                f\"Attachments are not enabled for {self.hubuum_class.name}.\"\n            )\n\n        return Attachment.objects.filter(hubuum_class=self.hubuum_class, hubuum_object=self)\n\n    def attachment_count(self) -&gt; int:\n\"\"\"Return the number of attachments registered to the object.\"\"\"\n        return self.attachments().count()\n\n    def attachment_size(self) -&gt; int:\n\"\"\"Return the total size of all attachments registered to the object.\"\"\"\n        return sum(attachment.size for attachment in self.attachments())\n\n    def attachment_individual_size_limit(self) -&gt; int:\n\"\"\"Return the max size of an attachment for the object.\"\"\"\n        return AttachmentManager.objects.get(\n            hubuum_class=self.hubuum_class, enabled=True\n        ).per_object_individual_size_limit\n\n    def attachment_total_size_limit(self) -&gt; int:\n\"\"\"Return the size limit of attachments for the object.\"\"\"\n        return AttachmentManager.objects.get(\n            hubuum_class=self.hubuum_class, enabled=True\n        ).per_object_total_size_limit\n\n    def attachment_count_limit(self) -&gt; int:\n\"\"\"Return the count limit of attachments for the object.\"\"\"\n        return AttachmentManager.objects.get(\n            hubuum_class=self.hubuum_class, enabled=True\n        ).per_object_count_limit\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel.Meta","title":"<code>Meta</code>","text":"<p>Meta for the model.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Meta:\n\"\"\"Meta for the model.\"\"\"\n\n    abstract = True\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel.attachment_count","title":"<code>attachment_count()</code>","text":"<p>Return the number of attachments registered to the object.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def attachment_count(self) -&gt; int:\n\"\"\"Return the number of attachments registered to the object.\"\"\"\n    return self.attachments().count()\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel.attachment_count_limit","title":"<code>attachment_count_limit()</code>","text":"<p>Return the count limit of attachments for the object.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def attachment_count_limit(self) -&gt; int:\n\"\"\"Return the count limit of attachments for the object.\"\"\"\n    return AttachmentManager.objects.get(\n        hubuum_class=self.hubuum_class, enabled=True\n    ).per_object_count_limit\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel.attachment_individual_size_limit","title":"<code>attachment_individual_size_limit()</code>","text":"<p>Return the max size of an attachment for the object.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def attachment_individual_size_limit(self) -&gt; int:\n\"\"\"Return the max size of an attachment for the object.\"\"\"\n    return AttachmentManager.objects.get(\n        hubuum_class=self.hubuum_class, enabled=True\n    ).per_object_individual_size_limit\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel.attachment_size","title":"<code>attachment_size()</code>","text":"<p>Return the total size of all attachments registered to the object.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def attachment_size(self) -&gt; int:\n\"\"\"Return the total size of all attachments registered to the object.\"\"\"\n    return sum(attachment.size for attachment in self.attachments())\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel.attachment_total_size_limit","title":"<code>attachment_total_size_limit()</code>","text":"<p>Return the size limit of attachments for the object.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def attachment_total_size_limit(self) -&gt; int:\n\"\"\"Return the size limit of attachments for the object.\"\"\"\n    return AttachmentManager.objects.get(\n        hubuum_class=self.hubuum_class, enabled=True\n    ).per_object_total_size_limit\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel.attachments","title":"<code>attachments()</code>","text":"<p>List all attachments registered to the object.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def attachments(self) -&gt; List[Attachment]:\n\"\"\"List all attachments registered to the object.\"\"\"\n    if not self.attachments_are_enabled():\n        raise UnsupportedAttachmentModelError(\n            f\"Attachments are not enabled for {self.hubuum_class.name}.\"\n        )\n\n    return Attachment.objects.filter(hubuum_class=self.hubuum_class, hubuum_object=self)\n</code></pre>"},{"location":"model/#hubuum.models.core.AttachmentModel.attachments_are_enabled","title":"<code>attachments_are_enabled()</code>","text":"<p>Check if the model is ready to receive attachments.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def attachments_are_enabled(self) -&gt; bool:\n\"\"\"Check if the model is ready to receive attachments.\"\"\"\n    return AttachmentManager.objects.filter(\n        hubuum_class=self.hubuum_class, enabled=True\n    ).exists()\n</code></pre>"},{"location":"model/#hubuum.models.core.ClassLink","title":"<code>ClassLink</code>","text":"<p>         Bases: <code>NamespacedHubuumModel</code></p> <p>A user-created link type between two classes.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class ClassLink(NamespacedHubuumModel):\n\"\"\"A user-created link type between two classes.\"\"\"\n\n    source_class = models.ForeignKey(\n        HubuumClass, related_name=\"source_links\", on_delete=models.CASCADE\n    )\n    target_class = models.ForeignKey(\n        HubuumClass, related_name=\"target_links\", on_delete=models.CASCADE\n    )\n    max_links = models.IntegerField()\n\n    class Meta:\n\"\"\"Define the ClassLink model's meta data.\"\"\"\n\n        unique_together = [\"source_class\", \"target_class\"]\n\n    def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the ClassLink instance.\"\"\"\n        return f\"{self.source_class.name} &lt;-&gt; {self.target_class.name} ({self.max_links})\"\n</code></pre>"},{"location":"model/#hubuum.models.core.ClassLink.Meta","title":"<code>Meta</code>","text":"<p>Define the ClassLink model's meta data.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Meta:\n\"\"\"Define the ClassLink model's meta data.\"\"\"\n\n    unique_together = [\"source_class\", \"target_class\"]\n</code></pre>"},{"location":"model/#hubuum.models.core.ClassLink.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the ClassLink instance.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the ClassLink instance.\"\"\"\n    return f\"{self.source_class.name} &lt;-&gt; {self.target_class.name} ({self.max_links})\"\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumClass","title":"<code>HubuumClass</code>","text":"<p>         Bases: <code>NamespacedHubuumModel</code></p> <p>A user-created 'class'/'model'.</p> <p>:param name: The name of the class. :param json_schema: The JSON schema of the class (optional) :param validate_schema: A boolean indicating if the schema should be validated (optional). :param namespace: The namespace the class belongs to.</p> <p>The idea with namespaces for classes is that access to the entire structure may be limited to a specific set of users who can perform actions on this namespace.</p> <p>:raises: rest_framework.exceptions.ValidationError if the proposed schema is not valid.</p> <p>:return: A HubuumClass instance.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class HubuumClass(NamespacedHubuumModel):\n\"\"\"A user-created 'class'/'model'.\n\n    :param name: The name of the class.\n    :param json_schema: The JSON schema of the class (optional)\n    :param validate_schema: A boolean indicating if the schema should be validated (optional).\n    :param namespace: The namespace the class belongs to.\n\n    The idea with namespaces for classes is that access to the entire structure may be limited\n    to a specific set of users who can perform actions on this namespace.\n\n    :raises: rest_framework.exceptions.ValidationError if the proposed schema is not valid.\n\n    :return: A HubuumClass instance.\n    \"\"\"\n\n    name = models.CharField(max_length=200, null=False, unique=True)\n    json_schema = JSONField(blank=True, null=True)\n    validate_schema = models.BooleanField(default=False)\n\n    def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the HubuumClass instance.\n\n        :return: A string representation of the HubuumClass instance.\n        \"\"\"\n        return f\"{self.name}\"\n\n    def get_object(self, identifier: str) -&gt; Optional[\"HubuumObject\"]:\n\"\"\"Retrieve a HubuumObject instance based on its name or primary key.\n\n        Tries to find the object first by its name, and if not found, by its primary\n        key (if `identifier` is a digit-only string). If the object is not found,\n        returns None.\n\n        :param identifier: The name or primary key of the object.\n        :return: The found HubuumObject instance, or None if not found.\n        \"\"\"\n        try:\n            return HubuumObject.objects.get(name=identifier, hubuum_class=self)\n        except HubuumObject.DoesNotExist:\n            if identifier.isdigit():\n                try:\n                    return HubuumObject.objects.get(pk=identifier, hubuum_class=self)\n                except HubuumObject.DoesNotExist:\n                    pass\n\n        return None\n\n    def validate_schema_correctness(self, schema: Dict[str, Any]) -&gt; bool:\n\"\"\"Validate that a given JSON schema is well-formed.\"\"\"\n        try:\n            Draft7Validator.check_schema(schema)\n        except SchemaError as e:\n            raise DRFValidationError(f\"The proposed schema is not valid: {str(e)}\") from e\n\n    def validate_additive_schema_change(self, new_schema: Dict[str, Any]) -&gt; bool:\n\"\"\"Validate that a proposed schema change is additive.\n\n        :param new_schema: The proposed new JSON schema.\n\n        :return: A boolean indicating if the proposed schema is additive.\n\n        :raises: rest_framework.exceptions.ValidationError if the proposed schema\n                is not a valid JSON schema, or if the proposed schema change is\n                not additive.\n        \"\"\"\n        # First, we need to check if the new schema is a valid JSON schema.\n        self.validate_schema_correctness(new_schema)\n\n        old_schema: Dict[str, Any] = self.json_schema\n\n        # If there's no old schema, any valid new schema is considered additive.\n        # However, this should only be called on update, so this should never happen.\n        # if not old_schema:\n        #    return True\n\n        def check_subset(old: Dict[str, Any], new: Dict[str, Any]) -&gt; bool:\n            for key, old_val in old.items():\n                if key not in new:\n                    return False\n                new_val = new[key]\n                if isinstance(old_val, dict) and isinstance(new_val, dict):\n                    if not check_subset(old_val, new_val):\n                        return False\n            return True\n\n        if check_subset(old_schema, new_schema):\n            # This means every key in the old schema is present in the new schema.\n            # Therefore the new schema is considered an additive change.\n            return True\n        else:\n            raise DRFValidationError(\"Schema changes must be additive.\")\n\n    def get_transitive_paths(\n        self, target_class: str, max_depth: int = 0\n    ) -&gt; List[List[\"ClassLink\"]]:\n\"\"\"Produce all possible paths that can lead from self to target_class.\n\n        Each path is represented as a list of ClassLinks.\n        \"\"\"\n        queue = deque(\n            [([], self, set([self]))]\n        )  # queue elements are: (path, class, visited classes)\n        paths = []\n\n        # Get the HubuumClass object for the target class.\n        target_class = HubuumClass.objects.get(name=target_class)\n\n        while queue:\n            path, node, visited = queue.popleft()\n            if max_depth and len(path) &gt;= max_depth:\n                break\n            link_types = ClassLink.objects.filter(source_class=node)\n            for link_type in link_types:\n                if link_type.target_class in visited:\n                    continue  # Avoid cycles.\n                new_visited = visited.copy()\n                new_visited.add(link_type.target_class)\n                new_path = path + [link_type]\n                if link_type.target_class == target_class:\n                    paths.append(new_path)\n                else:\n                    queue.append((new_path, link_type.target_class, new_visited))\n\n        return paths\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumClass.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the HubuumClass instance.</p> <p>:return: A string representation of the HubuumClass instance.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the HubuumClass instance.\n\n    :return: A string representation of the HubuumClass instance.\n    \"\"\"\n    return f\"{self.name}\"\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumClass.get_object","title":"<code>get_object(identifier)</code>","text":"<p>Retrieve a HubuumObject instance based on its name or primary key.</p> <p>Tries to find the object first by its name, and if not found, by its primary key (if <code>identifier</code> is a digit-only string). If the object is not found, returns None.</p> <p>:param identifier: The name or primary key of the object. :return: The found HubuumObject instance, or None if not found.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def get_object(self, identifier: str) -&gt; Optional[\"HubuumObject\"]:\n\"\"\"Retrieve a HubuumObject instance based on its name or primary key.\n\n    Tries to find the object first by its name, and if not found, by its primary\n    key (if `identifier` is a digit-only string). If the object is not found,\n    returns None.\n\n    :param identifier: The name or primary key of the object.\n    :return: The found HubuumObject instance, or None if not found.\n    \"\"\"\n    try:\n        return HubuumObject.objects.get(name=identifier, hubuum_class=self)\n    except HubuumObject.DoesNotExist:\n        if identifier.isdigit():\n            try:\n                return HubuumObject.objects.get(pk=identifier, hubuum_class=self)\n            except HubuumObject.DoesNotExist:\n                pass\n\n    return None\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumClass.get_transitive_paths","title":"<code>get_transitive_paths(target_class, max_depth=0)</code>","text":"<p>Produce all possible paths that can lead from self to target_class.</p> <p>Each path is represented as a list of ClassLinks.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def get_transitive_paths(\n    self, target_class: str, max_depth: int = 0\n) -&gt; List[List[\"ClassLink\"]]:\n\"\"\"Produce all possible paths that can lead from self to target_class.\n\n    Each path is represented as a list of ClassLinks.\n    \"\"\"\n    queue = deque(\n        [([], self, set([self]))]\n    )  # queue elements are: (path, class, visited classes)\n    paths = []\n\n    # Get the HubuumClass object for the target class.\n    target_class = HubuumClass.objects.get(name=target_class)\n\n    while queue:\n        path, node, visited = queue.popleft()\n        if max_depth and len(path) &gt;= max_depth:\n            break\n        link_types = ClassLink.objects.filter(source_class=node)\n        for link_type in link_types:\n            if link_type.target_class in visited:\n                continue  # Avoid cycles.\n            new_visited = visited.copy()\n            new_visited.add(link_type.target_class)\n            new_path = path + [link_type]\n            if link_type.target_class == target_class:\n                paths.append(new_path)\n            else:\n                queue.append((new_path, link_type.target_class, new_visited))\n\n    return paths\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumClass.validate_additive_schema_change","title":"<code>validate_additive_schema_change(new_schema)</code>","text":"<p>Validate that a proposed schema change is additive.</p> <p>:param new_schema: The proposed new JSON schema.</p> <p>:return: A boolean indicating if the proposed schema is additive.</p> <p>:raises: rest_framework.exceptions.ValidationError if the proposed schema         is not a valid JSON schema, or if the proposed schema change is         not additive.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def validate_additive_schema_change(self, new_schema: Dict[str, Any]) -&gt; bool:\n\"\"\"Validate that a proposed schema change is additive.\n\n    :param new_schema: The proposed new JSON schema.\n\n    :return: A boolean indicating if the proposed schema is additive.\n\n    :raises: rest_framework.exceptions.ValidationError if the proposed schema\n            is not a valid JSON schema, or if the proposed schema change is\n            not additive.\n    \"\"\"\n    # First, we need to check if the new schema is a valid JSON schema.\n    self.validate_schema_correctness(new_schema)\n\n    old_schema: Dict[str, Any] = self.json_schema\n\n    # If there's no old schema, any valid new schema is considered additive.\n    # However, this should only be called on update, so this should never happen.\n    # if not old_schema:\n    #    return True\n\n    def check_subset(old: Dict[str, Any], new: Dict[str, Any]) -&gt; bool:\n        for key, old_val in old.items():\n            if key not in new:\n                return False\n            new_val = new[key]\n            if isinstance(old_val, dict) and isinstance(new_val, dict):\n                if not check_subset(old_val, new_val):\n                    return False\n        return True\n\n    if check_subset(old_schema, new_schema):\n        # This means every key in the old schema is present in the new schema.\n        # Therefore the new schema is considered an additive change.\n        return True\n    else:\n        raise DRFValidationError(\"Schema changes must be additive.\")\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumClass.validate_schema_correctness","title":"<code>validate_schema_correctness(schema)</code>","text":"<p>Validate that a given JSON schema is well-formed.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def validate_schema_correctness(self, schema: Dict[str, Any]) -&gt; bool:\n\"\"\"Validate that a given JSON schema is well-formed.\"\"\"\n    try:\n        Draft7Validator.check_schema(schema)\n    except SchemaError as e:\n        raise DRFValidationError(f\"The proposed schema is not valid: {str(e)}\") from e\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumModel","title":"<code>HubuumModel</code>","text":"<p>         Bases: <code>models.Model</code></p> <p>Base model for Hubuum Objects.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class HubuumModel(models.Model):\n\"\"\"Base model for Hubuum Objects.\"\"\"\n\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    readonly_fields = (\n        \"created_at\",\n        \"updated_at\",\n    )\n\n    class Meta:\n\"\"\"Meta data for the class.\"\"\"\n\n        abstract = True\n\n    def get_auto_id(self) -&gt; int:\n\"\"\"Get the auto ID of the object.\"\"\"\n        return cast(int, self.id)\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumModel.Meta","title":"<code>Meta</code>","text":"<p>Meta data for the class.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Meta:\n\"\"\"Meta data for the class.\"\"\"\n\n    abstract = True\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumModel.get_auto_id","title":"<code>get_auto_id()</code>","text":"<p>Get the auto ID of the object.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def get_auto_id(self) -&gt; int:\n\"\"\"Get the auto ID of the object.\"\"\"\n    return cast(int, self.id)\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumObject","title":"<code>HubuumObject</code>","text":"<p>         Bases: <code>NamespacedHubuumModel</code>, <code>AttachmentModel</code></p> <p>A user-created object.</p> <p>:param name: The name of the object. :param hubuum_class: The class of the object. :param json_data: The data of the object. :param namespace: The namespace the object belongs to.</p> <p>:raises: rest_framework.exceptions.ValidationError if the instance data is invalid.</p> <p>:return: A HubuumObject instance.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class HubuumObject(NamespacedHubuumModel, AttachmentModel):\n\"\"\"A user-created object.\n\n    :param name: The name of the object.\n    :param hubuum_class: The class of the object.\n    :param json_data: The data of the object.\n    :param namespace: The namespace the object belongs to.\n\n    :raises: rest_framework.exceptions.ValidationError if the instance data is invalid.\n\n    :return: A HubuumObject instance.\n\n    \"\"\"\n\n    name = models.CharField(max_length=200, null=False)\n    hubuum_class = models.ForeignKey(HubuumClass, null=False, on_delete=models.CASCADE)\n    json_data = JSONField()\n\n    class Meta:\n\"\"\"Define the HubuumObjects model's meta data.\"\"\"\n\n        unique_together = [\"name\", \"hubuum_class\"]\n\n    def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the HubuumObject instance.\n\n        :return: A string representation of the HubuumObject instance.\n        \"\"\"\n        return f\"{self.name} [{self.hubuum_class.name}]\"\n\n    def save(self, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Save the HubuumObject instance.\n\n        Validates the instance data if validation is required.\n        \"\"\"\n        self.validate_json()\n        super().save(*args, **kwargs)\n\n    def has_schema(self) -&gt; bool:\n\"\"\"Determine if a JSON schema exists for the HubuumObject instance.\n\n        :return: A boolean indicating if a JSON schema exists.\n        \"\"\"\n        return bool(self.hubuum_class.json_schema)\n\n    def validation_required(self) -&gt; bool:\n\"\"\"Determine if validation is required for the HubuumObject instance.\n\n        :return: A boolean indicating if validation is required.\n        \"\"\"\n        return self.hubuum_class.validate_schema\n\n    def validate_json(self) -&gt; bool:\n\"\"\"Validate the HubuumObject instance against its schema if validation is required.\n\n        :return: A boolean indicating if the instance data is valid.\n\n        :raises: rest_framework.exceptions.ValidationError if the instance data is not valid.\n        \"\"\"\n        if self.validation_required() and self.has_schema():\n            schema = self.hubuum_class.json_schema\n            try:\n                validate(instance=self.json_data, schema=schema)\n                return True\n            except SchemaValidationError as exc:\n                raise DRFValidationError(\n                    f\"Data is not valid according to schema: {str(exc)}\"\n                ) from exc\n        else:\n            # If validation is not required, we consider the instance valid by default.\n            return True\n\n    def find_transitive_links(\n        self, target_class: HubuumClass, max_depth: int = 0\n    ) -&gt; List[Dict[str, Union[\"HubuumObject\", List[\"ObjectLink\"]]]]:\n\"\"\"Find all paths from self to any object of target_class.\"\"\"\n        # Get the possible paths and early exit if there's no possible link to the target_class.\n        possible_paths = self.hubuum_class.get_transitive_paths(target_class, max_depth=max_depth)\n        if not possible_paths:\n            return []\n\n        def traverse(\n            possible_path: List[ClassLink], current_path: List[HubuumObject]\n        ) -&gt; List[List[HubuumObject]]:\n\"\"\"Traverse the possible paths and collect links that meet the path requirements.\"\"\"\n            # First, we check the possible ClassLinks for the current node.\n            # These are the class-based links.\n            traversed_path = []\n            if not possible_path:\n                return [current_path]\n\n            for link_type in possible_path:\n                object_links = current_path[-1].outbound_links.filter(link_type=link_type)\n                for link in object_links:\n                    traversed_path.extend(\n                        traverse(possible_path[1:], current_path + [link.target])\n                    )\n\n            return traversed_path\n\n        # Traverse the possible paths and collect the links that meet the path requirements.\n        paths = []\n        for possible_path in possible_paths:\n            object_paths = traverse(possible_path, [self])\n\n            # If we reached the end of the path and the last node's class is the target class,\n            # then we successfully found a path.\n            for objects in object_paths:\n                paths.append({\"object\": objects[-1], \"path\": objects})\n\n        return paths\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumObject.Meta","title":"<code>Meta</code>","text":"<p>Define the HubuumObjects model's meta data.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Meta:\n\"\"\"Define the HubuumObjects model's meta data.\"\"\"\n\n    unique_together = [\"name\", \"hubuum_class\"]\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumObject.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the HubuumObject instance.</p> <p>:return: A string representation of the HubuumObject instance.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the HubuumObject instance.\n\n    :return: A string representation of the HubuumObject instance.\n    \"\"\"\n    return f\"{self.name} [{self.hubuum_class.name}]\"\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumObject.find_transitive_links","title":"<code>find_transitive_links(target_class, max_depth=0)</code>","text":"<p>Find all paths from self to any object of target_class.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def find_transitive_links(\n    self, target_class: HubuumClass, max_depth: int = 0\n) -&gt; List[Dict[str, Union[\"HubuumObject\", List[\"ObjectLink\"]]]]:\n\"\"\"Find all paths from self to any object of target_class.\"\"\"\n    # Get the possible paths and early exit if there's no possible link to the target_class.\n    possible_paths = self.hubuum_class.get_transitive_paths(target_class, max_depth=max_depth)\n    if not possible_paths:\n        return []\n\n    def traverse(\n        possible_path: List[ClassLink], current_path: List[HubuumObject]\n    ) -&gt; List[List[HubuumObject]]:\n\"\"\"Traverse the possible paths and collect links that meet the path requirements.\"\"\"\n        # First, we check the possible ClassLinks for the current node.\n        # These are the class-based links.\n        traversed_path = []\n        if not possible_path:\n            return [current_path]\n\n        for link_type in possible_path:\n            object_links = current_path[-1].outbound_links.filter(link_type=link_type)\n            for link in object_links:\n                traversed_path.extend(\n                    traverse(possible_path[1:], current_path + [link.target])\n                )\n\n        return traversed_path\n\n    # Traverse the possible paths and collect the links that meet the path requirements.\n    paths = []\n    for possible_path in possible_paths:\n        object_paths = traverse(possible_path, [self])\n\n        # If we reached the end of the path and the last node's class is the target class,\n        # then we successfully found a path.\n        for objects in object_paths:\n            paths.append({\"object\": objects[-1], \"path\": objects})\n\n    return paths\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumObject.has_schema","title":"<code>has_schema()</code>","text":"<p>Determine if a JSON schema exists for the HubuumObject instance.</p> <p>:return: A boolean indicating if a JSON schema exists.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def has_schema(self) -&gt; bool:\n\"\"\"Determine if a JSON schema exists for the HubuumObject instance.\n\n    :return: A boolean indicating if a JSON schema exists.\n    \"\"\"\n    return bool(self.hubuum_class.json_schema)\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumObject.save","title":"<code>save(*args, **kwargs)</code>","text":"<p>Save the HubuumObject instance.</p> <p>Validates the instance data if validation is required.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def save(self, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Save the HubuumObject instance.\n\n    Validates the instance data if validation is required.\n    \"\"\"\n    self.validate_json()\n    super().save(*args, **kwargs)\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumObject.validate_json","title":"<code>validate_json()</code>","text":"<p>Validate the HubuumObject instance against its schema if validation is required.</p> <p>:return: A boolean indicating if the instance data is valid.</p> <p>:raises: rest_framework.exceptions.ValidationError if the instance data is not valid.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def validate_json(self) -&gt; bool:\n\"\"\"Validate the HubuumObject instance against its schema if validation is required.\n\n    :return: A boolean indicating if the instance data is valid.\n\n    :raises: rest_framework.exceptions.ValidationError if the instance data is not valid.\n    \"\"\"\n    if self.validation_required() and self.has_schema():\n        schema = self.hubuum_class.json_schema\n        try:\n            validate(instance=self.json_data, schema=schema)\n            return True\n        except SchemaValidationError as exc:\n            raise DRFValidationError(\n                f\"Data is not valid according to schema: {str(exc)}\"\n            ) from exc\n    else:\n        # If validation is not required, we consider the instance valid by default.\n        return True\n</code></pre>"},{"location":"model/#hubuum.models.core.HubuumObject.validation_required","title":"<code>validation_required()</code>","text":"<p>Determine if validation is required for the HubuumObject instance.</p> <p>:return: A boolean indicating if validation is required.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def validation_required(self) -&gt; bool:\n\"\"\"Determine if validation is required for the HubuumObject instance.\n\n    :return: A boolean indicating if validation is required.\n    \"\"\"\n    return self.hubuum_class.validate_schema\n</code></pre>"},{"location":"model/#hubuum.models.core.NamespacedHubuumModel","title":"<code>NamespacedHubuumModel</code>","text":"<p>         Bases: <code>HubuumModel</code></p> <p>Base model for a namespaced Hubuum Objects.</p> Adds the following fields <p>namespace: The namespace the object belongs to.</p> <p>Inherits from HubuumModel, which and adds the following fields:     created_at: The date and time the object was created.     updated_at: The date and time the object was last updated.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class NamespacedHubuumModel(HubuumModel):\n\"\"\"Base model for a namespaced Hubuum Objects.\n\n    Adds the following fields:\n        namespace: The namespace the object belongs to.\n\n    Inherits from HubuumModel, which and adds the following fields:\n        created_at: The date and time the object was created.\n        updated_at: The date and time the object was last updated.\n    \"\"\"\n\n    # When we delete a namespace, do we want *all* the objects to disappear?\n    # That'd be harsh. But, well... What is the realistic option?\n    namespace: int = models.ForeignKey(\n        \"Namespace\",\n        on_delete=models.CASCADE,\n        blank=False,\n        null=False,\n    )\n\n    class Meta:\n\"\"\"Meta data for the class.\"\"\"\n\n        abstract = True\n</code></pre>"},{"location":"model/#hubuum.models.core.NamespacedHubuumModel.Meta","title":"<code>Meta</code>","text":"<p>Meta data for the class.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Meta:\n\"\"\"Meta data for the class.\"\"\"\n\n    abstract = True\n</code></pre>"},{"location":"model/#hubuum.models.core.ObjectLink","title":"<code>ObjectLink</code>","text":"<p>         Bases: <code>NamespacedHubuumModel</code></p> <p>ObjectLink model represents a user-defined link between two objects.</p> <p>The model inherits from NamespacedHubuumModel, which includes fields:     namespace: The namespace the object belongs to.     created_at: The date and time the object was created.     updated_at: The date and time the object was last updated.</p> <p>Fields: - source: The source object of the link. - target: The target object of the link. - link_type: A ForeignKey to the ClassLink model which defines the type of the link.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class ObjectLink(NamespacedHubuumModel):\n\"\"\"ObjectLink model represents a user-defined link between two objects.\n\n    The model inherits from NamespacedHubuumModel, which includes fields:\n        namespace: The namespace the object belongs to.\n        created_at: The date and time the object was created.\n        updated_at: The date and time the object was last updated.\n\n    Fields:\n    - source: The source object of the link.\n    - target: The target object of the link.\n    - link_type: A ForeignKey to the ClassLink model which defines the type of the link.\n    \"\"\"\n\n    source = models.ForeignKey(\n        \"HubuumObject\",\n        on_delete=models.CASCADE,\n        related_name=\"outbound_links\",\n    )\n    target = models.ForeignKey(\n        \"HubuumObject\",\n        on_delete=models.CASCADE,\n        related_name=\"inbound_links\",\n    )\n    link_type = models.ForeignKey(\n        \"ClassLink\",\n        on_delete=models.CASCADE,\n        related_name=\"links\",\n    )\n\n    class Meta:\n\"\"\"Define the ObjectLink model's meta data.\"\"\"\n\n        unique_together = [\"source\", \"target\"]\n\n    def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the ObjectLink instance.\"\"\"\n        return f\"{self.source} &lt;-&gt; {self.target}\"\n</code></pre>"},{"location":"model/#hubuum.models.core.ObjectLink.Meta","title":"<code>Meta</code>","text":"<p>Define the ObjectLink model's meta data.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>class Meta:\n\"\"\"Define the ObjectLink model's meta data.\"\"\"\n\n    unique_together = [\"source\", \"target\"]\n</code></pre>"},{"location":"model/#hubuum.models.core.ObjectLink.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the ObjectLink instance.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the ObjectLink instance.\"\"\"\n    return f\"{self.source} &lt;-&gt; {self.target}\"\n</code></pre>"},{"location":"model/#hubuum.models.core.model_is_open","title":"<code>model_is_open(model)</code>","text":"<p>Check if the model is an open model.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def model_is_open(model: str) -&gt; bool:\n\"\"\"Check if the model is an open model.\"\"\"\n    return model in models_that_are_open()\n</code></pre>"},{"location":"model/#hubuum.models.core.models_that_are_open","title":"<code>models_that_are_open()</code>","text":"<p>Return a list of models open to all authenticated users.</p> Source code in <code>hubuum/models/core.py</code> <pre><code>def models_that_are_open() -&gt; Tuple[str]:\n\"\"\"Return a list of models open to all authenticated users.\"\"\"\n    return (\"user\", \"group\")\n</code></pre>"},{"location":"model/#iam","title":"IAM","text":"<p>Models related to the identity management and permissions.</p> <p>IAM-related models for the hubuum project.</p>"},{"location":"model/#hubuum.models.iam.Namespace","title":"<code>Namespace</code>","text":"<p>         Bases: <code>HubuumModel</code></p> <p>The namespace ('domain') of an object.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>class Namespace(HubuumModel):\n\"\"\"The namespace ('domain') of an object.\"\"\"\n\n    name = models.CharField(max_length=255, unique=True)\n    description = models.TextField(blank=True)\n\n    def get_permissions_for_group(self, group: Group, raise_exception: bool = True) -&gt; Permission:\n\"\"\"Try to find a permission object for the given group.\n\n        param: group (Group instance)\n        param: raise_exception (True)\n\n        Returns\n        -------\n            success (Permission): Permission object\n            failure (None): None\n\n        Raises\n        ------\n            exception: NotFound if raise_exception is True and no permission object is found\n\n        \"\"\"\n        try:\n            obj = Permission.objects.get(namespace=self, group=group)\n            return obj\n        except Permission.DoesNotExist as exc:\n            if raise_exception:\n                raise NotFound() from exc\n\n        return None\n\n    def grant_all(self, group: Group) -&gt; bool:\n\"\"\"Grant all permissions to the namespace to the given group.\"\"\"\n        create: Dict[str, Any] = {}\n        create[\"namespace\"] = self\n        create[\"group\"] = group\n        for perm in namespace_operations(fully_qualified=True):\n            create[perm] = True\n        Permission.objects.update_or_create(**create)\n        return True\n\n    def groups_that_can(self, perm: str) -&gt; List[Group]:\n\"\"\"Fetch groups that can perform a specific permission.\n\n        param: perm (permission string, 'has_[read|create|update|delete|namespace])\n        return [group objects] (may be empty)\n        \"\"\"\n        qs = Permission.objects.filter(namespace=self.id, **{perm: True}).values(\"group\")\n        groups = Group.objects.filter(id__in=qs)\n        return groups\n\n    class Meta:\n\"\"\"Meta for the model.\"\"\"\n\n        ordering = [\"id\"]\n\n    def __str__(self) -&gt; str:\n\"\"\"Stringify the object, used to represent the object towards users.\"\"\"\n        return self.name\n</code></pre>"},{"location":"model/#hubuum.models.iam.Namespace.Meta","title":"<code>Meta</code>","text":"<p>Meta for the model.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>class Meta:\n\"\"\"Meta for the model.\"\"\"\n\n    ordering = [\"id\"]\n</code></pre>"},{"location":"model/#hubuum.models.iam.Namespace.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the object, used to represent the object towards users.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Stringify the object, used to represent the object towards users.\"\"\"\n    return self.name\n</code></pre>"},{"location":"model/#hubuum.models.iam.Namespace.get_permissions_for_group","title":"<code>get_permissions_for_group(group, raise_exception=True)</code>","text":"<p>Try to find a permission object for the given group.</p> <p>param: group (Group instance) param: raise_exception (True)</p>"},{"location":"model/#hubuum.models.iam.Namespace.get_permissions_for_group--returns","title":"Returns","text":"<pre><code>success (Permission): Permission object\nfailure (None): None\n</code></pre>"},{"location":"model/#hubuum.models.iam.Namespace.get_permissions_for_group--raises","title":"Raises","text":"<pre><code>exception: NotFound if raise_exception is True and no permission object is found\n</code></pre> Source code in <code>hubuum/models/iam.py</code> <pre><code>def get_permissions_for_group(self, group: Group, raise_exception: bool = True) -&gt; Permission:\n\"\"\"Try to find a permission object for the given group.\n\n    param: group (Group instance)\n    param: raise_exception (True)\n\n    Returns\n    -------\n        success (Permission): Permission object\n        failure (None): None\n\n    Raises\n    ------\n        exception: NotFound if raise_exception is True and no permission object is found\n\n    \"\"\"\n    try:\n        obj = Permission.objects.get(namespace=self, group=group)\n        return obj\n    except Permission.DoesNotExist as exc:\n        if raise_exception:\n            raise NotFound() from exc\n\n    return None\n</code></pre>"},{"location":"model/#hubuum.models.iam.Namespace.grant_all","title":"<code>grant_all(group)</code>","text":"<p>Grant all permissions to the namespace to the given group.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def grant_all(self, group: Group) -&gt; bool:\n\"\"\"Grant all permissions to the namespace to the given group.\"\"\"\n    create: Dict[str, Any] = {}\n    create[\"namespace\"] = self\n    create[\"group\"] = group\n    for perm in namespace_operations(fully_qualified=True):\n        create[perm] = True\n    Permission.objects.update_or_create(**create)\n    return True\n</code></pre>"},{"location":"model/#hubuum.models.iam.Namespace.groups_that_can","title":"<code>groups_that_can(perm)</code>","text":"<p>Fetch groups that can perform a specific permission.</p> <p>param: perm (permission string, 'has_[read|create|update|delete|namespace]) return [group objects] (may be empty)</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def groups_that_can(self, perm: str) -&gt; List[Group]:\n\"\"\"Fetch groups that can perform a specific permission.\n\n    param: perm (permission string, 'has_[read|create|update|delete|namespace])\n    return [group objects] (may be empty)\n    \"\"\"\n    qs = Permission.objects.filter(namespace=self.id, **{perm: True}).values(\"group\")\n    groups = Group.objects.filter(id__in=qs)\n    return groups\n</code></pre>"},{"location":"model/#hubuum.models.iam.Permission","title":"<code>Permission</code>","text":"<p>         Bases: <code>HubuumModel</code></p> <p>Permissions in Hubuum.</p> <ul> <li>Permissions are set by group.</li> <li>Objects belong to a namespace.</li> <li>Every namespace has zero or more groups with permissions for the namespace.</li> </ul> <p>The permission <code>has_namespace</code> allows for the group to create new namespaces scoped under the current one.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>class Permission(HubuumModel):\n\"\"\"Permissions in Hubuum.\n\n    - Permissions are set by group.\n    - Objects belong to a namespace.\n    - Every namespace has zero or more groups with permissions for the namespace.\n\n    The permission `has_namespace` allows for the group to create new namespaces scoped\n    under the current one.\n    \"\"\"\n\n    # If the namespace the permission points to goes away, clear the entry.\n    namespace: int = models.ForeignKey(\n        \"Namespace\", related_name=\"p_namespace\", on_delete=models.CASCADE\n    )\n    # If the group the permission uses goes away, clear the entry.\n    group: int = models.ForeignKey(\"auth.Group\", related_name=\"p_group\", on_delete=models.CASCADE)\n\n    has_create = models.BooleanField(null=False, default=False)\n    has_read = models.BooleanField(null=False, default=False)\n    has_update = models.BooleanField(null=False, default=False)\n    has_delete = models.BooleanField(null=False, default=False)\n    has_namespace = models.BooleanField(null=False, default=False)\n\n    class Meta:\n\"\"\"Metadata permissions.\"\"\"\n\n        unique_together = (\"namespace\", \"group\")\n        ordering = [\"id\"]\n\n    def __str__(self) -&gt; str:\n\"\"\"Stringify the object, used to represent the object towards users.\"\"\"\n        return str(self.get_auto_id())\n</code></pre>"},{"location":"model/#hubuum.models.iam.Permission.Meta","title":"<code>Meta</code>","text":"<p>Metadata permissions.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>class Meta:\n\"\"\"Metadata permissions.\"\"\"\n\n    unique_together = (\"namespace\", \"group\")\n    ordering = [\"id\"]\n</code></pre>"},{"location":"model/#hubuum.models.iam.Permission.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the object, used to represent the object towards users.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Stringify the object, used to represent the object towards users.\"\"\"\n    return str(self.get_auto_id())\n</code></pre>"},{"location":"model/#hubuum.models.iam.User","title":"<code>User</code>","text":"<p>         Bases: <code>AbstractUser</code></p> <p>Extension to the default User class.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>class User(AbstractUser):\n\"\"\"Extension to the default User class.\"\"\"\n\n    model_permissions_pattern = re.compile(r\"^hubuum.(create|read|update|delete|namespace)$\")\n    lookup_fields = [\"id\", \"username\", \"email\"]\n\n    _group_list = None\n\n    def get_auto_id(self) -&gt; int:\n\"\"\"Return the auto id of the user.\"\"\"\n        return cast(int, self.id)\n\n    def is_admin(self):\n\"\"\"Check if the user is any type of admin (staff/superadmin) (or in a similar group?).\"\"\"\n        return self.is_staff or self.is_superuser\n\n    @property\n    def group_list(self) -&gt; List[str]:\n\"\"\"List the names of all the groups the user is a member of.\"\"\"\n        if self._group_list is None:\n            self._group_list = list(self.groups.values_list(\"name\", flat=True))\n        return self._group_list\n\n    def group_count(self) -&gt; int:\n\"\"\"Return the number of groups the user is a member of.\"\"\"\n        return self.groups.count()\n\n    def has_only_one_group(self) -&gt; bool:\n\"\"\"Return true if the user is a member of only one group.\"\"\"\n        return self.group_count() == 1\n\n    def is_member_of(self, group: Group) -&gt; bool:\n\"\"\"Check if the user is a member of a specific group.\"\"\"\n        return self.is_member_of_any([group])\n\n    def is_member_of_any(self, groups: List[Group]) -&gt; bool:\n\"\"\"Check to see if a user is a member of any of the groups in the list.\"\"\"\n        return bool([i for i in groups if i in self.groups.all()])\n\n    def namespaced_can(self, perm: str, namespace: Namespace) -&gt; bool:\n\"\"\"Check to see if the user can perform perm for namespace.\n\n        param: perm (permission string, 'has_[create|read|update|delete|namespace])\n        param: namespace (namespace object)\n        return True|False\n        \"\"\"\n        if not namespace_operation_exists(perm, fully_qualified=True):\n            raise MissingParam(f\"Unknown permission '{perm}' passed to namespaced_can.\")\n\n        # We need to check if the user is a member of a group\n        # that has the given permission the namespace.\n        groups = namespace.groups_that_can(perm)\n        return self.is_member_of_any(groups)\n\n    def has_namespace(\n        self,\n        namespace: Union[str, int],\n        write_perm: str = \"has_namespace\",\n    ):\n\"\"\"Check if the user has namespace permissions for the given namespace.\n\n        Only admin users can create or populate root namespaces.\n\n        For users, if the namespace isn't scoped (contains no dots), return False.\n        Otherwise, check if the user can:\n          - create the namespace (using has_namespace) or,\n          - create objects in the namespace (using has_create) on the last element.\n        \"\"\"\n        if isinstance(namespace, int):\n            try:\n                namespace_obj = Namespace.objects.get(pk=namespace)\n                return self.namespaced_can(write_perm, namespace_obj)\n            except Namespace.DoesNotExist as exc:\n                raise NotFound from exc\n\n        scope = namespace.split(\".\")\n        if len(scope) == 1:\n            return False\n\n        # This needs fixing for sub-namespaces.\n        target = scope\n        if write_perm == \"has_namespace\":\n            target = scope[-2]\n\n        try:\n            namespace_obj = Namespace.objects.get(name=target)\n        except Namespace.DoesNotExist as exc:\n            raise NotFound from exc\n\n        return self.namespaced_can(write_perm, namespace_obj)\n\n    #        try:\n    #            parent = Namespace.objects.get(name=scope[-1])\n    #        except Namespace.DoesNotExist:\n    #            return False\n\n    #        return Permission.objects.filter(\n    #            namespace=parent.id, has_namespace=True, group__in=self.groups.all()\n    #        ).exists()\n\n    # We want to ask for a HubuumNamespaceModel objects, but due to overloading we must\n    # also support user objects, anonymous users, generic django models, and None.\n    def has_perm(\n        self, perm: str, obj: Union[Model, AbstractUser, AnonymousUser, None] = None\n    ) -&gt; bool:\n\"\"\"Model (?) permissions check for an object.\n\n        perm: see permissions.py\n        obj: Hubuum Object\n        \"\"\"\n        field = None\n\n        match = re.match(User.model_permissions_pattern, perm)\n        if not match:\n            raise MissingParam(f\"Unknown permission '{perm}' passed to has_perm\")\n        field = \"has_\" + match.groups()[0]\n\n        # We should always get an object to test against.\n        if obj:\n            return Permission.objects.filter(\n                namespace=obj.namespace, **{field: True}, group__in=self.groups.all()\n            ).exists()\n\n        return False\n\n    class Meta:\n\"\"\"Meta class for User.\"\"\"\n\n        ordering = [\"id\"]\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.group_list","title":"<code>group_list: List[str]</code>  <code>property</code>","text":"<p>List the names of all the groups the user is a member of.</p>"},{"location":"model/#hubuum.models.iam.User.Meta","title":"<code>Meta</code>","text":"<p>Meta class for User.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>class Meta:\n\"\"\"Meta class for User.\"\"\"\n\n    ordering = [\"id\"]\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.get_auto_id","title":"<code>get_auto_id()</code>","text":"<p>Return the auto id of the user.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def get_auto_id(self) -&gt; int:\n\"\"\"Return the auto id of the user.\"\"\"\n    return cast(int, self.id)\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.group_count","title":"<code>group_count()</code>","text":"<p>Return the number of groups the user is a member of.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def group_count(self) -&gt; int:\n\"\"\"Return the number of groups the user is a member of.\"\"\"\n    return self.groups.count()\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.has_namespace","title":"<code>has_namespace(namespace, write_perm='has_namespace')</code>","text":"<p>Check if the user has namespace permissions for the given namespace.</p> <p>Only admin users can create or populate root namespaces.</p> <p>For users, if the namespace isn't scoped (contains no dots), return False. Otherwise, check if the user can:   - create the namespace (using has_namespace) or,   - create objects in the namespace (using has_create) on the last element.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def has_namespace(\n    self,\n    namespace: Union[str, int],\n    write_perm: str = \"has_namespace\",\n):\n\"\"\"Check if the user has namespace permissions for the given namespace.\n\n    Only admin users can create or populate root namespaces.\n\n    For users, if the namespace isn't scoped (contains no dots), return False.\n    Otherwise, check if the user can:\n      - create the namespace (using has_namespace) or,\n      - create objects in the namespace (using has_create) on the last element.\n    \"\"\"\n    if isinstance(namespace, int):\n        try:\n            namespace_obj = Namespace.objects.get(pk=namespace)\n            return self.namespaced_can(write_perm, namespace_obj)\n        except Namespace.DoesNotExist as exc:\n            raise NotFound from exc\n\n    scope = namespace.split(\".\")\n    if len(scope) == 1:\n        return False\n\n    # This needs fixing for sub-namespaces.\n    target = scope\n    if write_perm == \"has_namespace\":\n        target = scope[-2]\n\n    try:\n        namespace_obj = Namespace.objects.get(name=target)\n    except Namespace.DoesNotExist as exc:\n        raise NotFound from exc\n\n    return self.namespaced_can(write_perm, namespace_obj)\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.has_only_one_group","title":"<code>has_only_one_group()</code>","text":"<p>Return true if the user is a member of only one group.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def has_only_one_group(self) -&gt; bool:\n\"\"\"Return true if the user is a member of only one group.\"\"\"\n    return self.group_count() == 1\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.has_perm","title":"<code>has_perm(perm, obj=None)</code>","text":"<p>Model (?) permissions check for an object.</p> <p>perm: see permissions.py obj: Hubuum Object</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def has_perm(\n    self, perm: str, obj: Union[Model, AbstractUser, AnonymousUser, None] = None\n) -&gt; bool:\n\"\"\"Model (?) permissions check for an object.\n\n    perm: see permissions.py\n    obj: Hubuum Object\n    \"\"\"\n    field = None\n\n    match = re.match(User.model_permissions_pattern, perm)\n    if not match:\n        raise MissingParam(f\"Unknown permission '{perm}' passed to has_perm\")\n    field = \"has_\" + match.groups()[0]\n\n    # We should always get an object to test against.\n    if obj:\n        return Permission.objects.filter(\n            namespace=obj.namespace, **{field: True}, group__in=self.groups.all()\n        ).exists()\n\n    return False\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.is_admin","title":"<code>is_admin()</code>","text":"<p>Check if the user is any type of admin (staff/superadmin) (or in a similar group?).</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def is_admin(self):\n\"\"\"Check if the user is any type of admin (staff/superadmin) (or in a similar group?).\"\"\"\n    return self.is_staff or self.is_superuser\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.is_member_of","title":"<code>is_member_of(group)</code>","text":"<p>Check if the user is a member of a specific group.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def is_member_of(self, group: Group) -&gt; bool:\n\"\"\"Check if the user is a member of a specific group.\"\"\"\n    return self.is_member_of_any([group])\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.is_member_of_any","title":"<code>is_member_of_any(groups)</code>","text":"<p>Check to see if a user is a member of any of the groups in the list.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def is_member_of_any(self, groups: List[Group]) -&gt; bool:\n\"\"\"Check to see if a user is a member of any of the groups in the list.\"\"\"\n    return bool([i for i in groups if i in self.groups.all()])\n</code></pre>"},{"location":"model/#hubuum.models.iam.User.namespaced_can","title":"<code>namespaced_can(perm, namespace)</code>","text":"<p>Check to see if the user can perform perm for namespace.</p> <p>param: perm (permission string, 'has_[create|read|update|delete|namespace]) param: namespace (namespace object) return True|False</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def namespaced_can(self, perm: str, namespace: Namespace) -&gt; bool:\n\"\"\"Check to see if the user can perform perm for namespace.\n\n    param: perm (permission string, 'has_[create|read|update|delete|namespace])\n    param: namespace (namespace object)\n    return True|False\n    \"\"\"\n    if not namespace_operation_exists(perm, fully_qualified=True):\n        raise MissingParam(f\"Unknown permission '{perm}' passed to namespaced_can.\")\n\n    # We need to check if the user is a member of a group\n    # that has the given permission the namespace.\n    groups = namespace.groups_that_can(perm)\n    return self.is_member_of_any(groups)\n</code></pre>"},{"location":"model/#hubuum.models.iam.get_group","title":"<code>get_group(group_identifier, raise_exception=True)</code>","text":"<p>Try to find a group based on the identifier.</p> <p>:param: group_identifier</p> <p>:return: group object</p> <p>:raises: NotFound if no object found.</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def get_group(group_identifier: str, raise_exception: bool = True) -&gt; Group:\n\"\"\"Try to find a group based on the identifier.\n\n    :param: group_identifier\n\n    :return: group object\n\n    :raises: NotFound if no object found.\n    \"\"\"\n    return get_object(\n        Group,\n        group_identifier,\n        lookup_fields=[\"id\", \"name\"],\n        raise_exception=raise_exception,\n    )\n</code></pre>"},{"location":"model/#hubuum.models.iam.get_user","title":"<code>get_user(user_identifier, raise_exception=True)</code>","text":"<p>Try to find a user based on the identifier.</p> <p>Searches in User.lookup_fields</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def get_user(user_identifier: str, raise_exception: bool = True) -&gt; User:\n\"\"\"Try to find a user based on the identifier.\n\n    Searches in User.lookup_fields\n    \"\"\"\n    return get_object(User, user_identifier, raise_exception=raise_exception)\n</code></pre>"},{"location":"model/#hubuum.models.iam.namespace_operation_exists","title":"<code>namespace_operation_exists(permission, fully_qualified=False)</code>","text":"<p>Check if a permission operation for a namespace exists.</p> <p>:param: permission (str) - the permission operation to check :param: fully_qualified (bool) - if True, the operation will be checked     against the fully qualified list of operations</p> <p>:returns: (bool) - True if the operation exists, False otherwise</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def namespace_operation_exists(permission: str, fully_qualified: bool = False) -&gt; bool:\n\"\"\"Check if a permission operation for a namespace exists.\n\n    :param: permission (str) - the permission operation to check\n    :param: fully_qualified (bool) - if True, the operation will be checked\n        against the fully qualified list of operations\n\n    :returns: (bool) - True if the operation exists, False otherwise\n    \"\"\"\n    if fully_qualified:\n        return permission in namespace_operations(fully_qualified=True)\n\n    return permission in namespace_operations()\n</code></pre>"},{"location":"model/#hubuum.models.iam.namespace_operations","title":"<code>namespace_operations(fully_qualified=False)</code>","text":"<p>Return a list of valid namespace permission operations.</p> <p>:param: fully_qualified (bool) - if True, the list will be fully qualified</p> <p>:returns: (list) - a list of valid namespace permission operations</p> Source code in <code>hubuum/models/iam.py</code> <pre><code>def namespace_operations(fully_qualified: bool = False) -&gt; List[str]:\n\"\"\"Return a list of valid namespace permission operations.\n\n    :param: fully_qualified (bool) - if True, the list will be fully qualified\n\n    :returns: (list) - a list of valid namespace permission operations\n    \"\"\"\n    operations: List[str] = [\"create\", \"read\", \"update\", \"delete\", \"namespace\"]\n    if fully_qualified:\n        operations = [\"has_\" + s for s in operations]\n\n    return operations\n</code></pre>"},{"location":"permissions/","title":"Permissions","text":""},{"location":"permissions/#overview","title":"Overview","text":"<p>Hubuum supports permissions based on <code>namespaces</code>. A namespace is a collection of objects, and each object belongs to one and only one namespace. A namespace can be thought of as a project, or a tenant.</p> <p>Groups are given access to namespaces based on one of five boolean permissions: <code>read</code>, <code>create</code>, <code>update</code>, <code>delete</code> and <code>namespace</code>. These permissions are described in detail below.</p> <ul> <li><code>read</code>: The group can read the objects in the namespace, but not create or update them.</li> <li><code>create</code>: The group can create objects in the namespace, read is implied.</li> <li><code>update</code>: The group can update objects in the namespace, read is implied.</li> <li><code>delete</code>: The group can delete objects in the namespace, read is implied.</li> <li><code>namespace</code>: The group can create, read, update and delete objects in the namespace, and also create, read, update and delete the namespace itself.</li> </ul>"},{"location":"permissions/#example-usage","title":"Example usage","text":"<pre><code>```bash\n# Create a new namespace\nPOST /api/v1/namespaces/ -d '{\n    \"name\": \"example_namespace\"\n}'\n\n# Create a new group\nPOST /api/v1/groups/ -d '{\n    \"name\": \"example_group\"\n}'\n\n# Give the group read access to the namespace\nPOST /api/v1/namespaces/example_namespace/groups/example_group -d '{\n    \"read\": true\n}'\n```\n</code></pre> <p>Warning</p> <p>Note that deleting a namespace deletes all classes and objects in the namespace, and also their relations! Deleting a namespace is a destructive act that cannot be undone. Deleting the namespace also deletes all permission objects for the namespace, but the groups themselves are not deleted.</p>"},{"location":"swagger/","title":"Swagger","text":""},{"location":"terminology/","title":"Terminology","text":""},{"location":"terminology/#namespace","title":"Namespace","text":"<p>A namespace is a collection that an object belongs to. Every object in hubuum belongs to one and only one namespace. A namespace is identified by a unique name. A namespace can have zero or more groups with permissions for the namespace, and these groups can have zero or more users. Each group has a set of permissions to the namespace in question.</p>"},{"location":"terminology/#class","title":"Class","text":"<p>Every data object in Hubuum belongs to a Hubuum Class. These classes are user-defined, and may optionally use JSON validation schemas to enforce data integrity. One may also attach a schema to a class but not enforce it, only to have Hubuum warn when objects break the contract.</p> <p>Classes are identified by a unique name.</p>"},{"location":"terminology/#object","title":"Object","text":"<p>An object is an instance of a class. It is a JSON document that may either be free-form or adhere to a JSON schema. Objects are identified by a unique name within each class.</p>"},{"location":"terminology/#group","title":"Group","text":"<p>Groups contain users and have permissions for any number of namespaces.</p>"},{"location":"unit-tests/","title":"Testing","text":"<p><code>tox</code> is used as the testing framework. Apart from running the same tests as <code>python manage.py test</code>, it will test against multiple permutations of supported python and django versions.</p> <p>Tox is also used to run linting (<code>tox -e format</code> and <code>tox -e flake8</code>), as well as coveragev via <code>tox -e coverage</code>.</p>"},{"location":"unit-tests/#running-tests","title":"Running tests","text":"<p>To run the tests, simply run <code>tox</code> in the root directory of the project.</p> <p>Note that you may also use pytest directly, but this will only run the tests against one version python and django. You do however get the option to use <code>pytest -k</code> to run a specific test, which is useful for debugging. pytest is also handy as adding <code>-s</code> will also show the output of print statements.</p> <p>A common workflow is to run <code>pytest -k path/to/test_something.py -s -vv</code> to run a specific test and see the output of print statements.</p>"},{"location":"unit-tests/#writing-tests","title":"Writing tests","text":"<p>Tests are seperated between core functionality and the API. Core functionality tests are located in <code>tests/</code> and API tests are located in <code>api/v1/tests/</code>.</p>"},{"location":"unit-tests/#testing-dynamic-classes","title":"Testing dynamic classes","text":"<p>There is a testing framework in place to make testing dynamic classes easier. See <code>tests/helpers/populators.py</code> and <code>api/v1/tests/helpers/populators.py</code> for inheritable classes to help set up test classes, objects, and data.</p>"},{"location":"what_is_hubuum/","title":"What is hubuum?","text":"<p>Hubuum is a REST service that provides a shared interface for your resources.</p>"},{"location":"what_is_hubuum/#why-hubuum","title":"Why hubuum?","text":"<p>Most content management systems (CMDBs) are strongly opinionated. They provide fairly strict models with user interfaces designed for those models and all their data. This design may not be ideal for every use case.</p> <p>CMDBs also like to be authoritative for any data they possess. The problem with this in this day and age, very often other highly dedicated systems are the authoritative sources of lots and lots data, and these sources typically come with very domain specific scraping tools.</p> <p>Via extensions you can tell Hubuum where to find your data, from as many sources as you like, and attach it to the same objects. Hubuum  provides a unified API to access this data, irrespective of its original source. You may have data coming from Active Directory, an MDM solution, automation tools, monitoring solutions, query tools (fleet/osquery/etc), or any other source, and you can use Hubuum to access all of it.</p> <p>With hubuum you can...</p> <ul> <li>define your own data structures and their relationships.</li> <li>populate your data structures as JSON, and enforce validation when required.</li> <li>draw in data from any source into any object, structuring it as your organization requires.</li> <li>look up and search within these JSON structures in an efficient way, via a REST interface.</li> <li>offload the work of searching and indexing to Hubuum, and focus on your data.</li> <li>control permissions to one object set in one application instead of having to do it in multiple places.</li> <li>know that REST is your interface, no matter what data you are accessing.</li> </ul> <p>Once upon a time your data was everywhere, each in its own silo. Now you can have it all in one place, and access it all through a single REST interface.</p>"}]}